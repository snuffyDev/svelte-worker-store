var I=Object.defineProperty;var i=(t,e)=>I(t,"name",{value:e,configurable:!0});function h(){}i(h,"noop");function E(t){return t()}i(E,"run");function w(t){t.forEach(E)}i(w,"run_all");function b(t){return typeof t=="function"}i(b,"is_function");function T(t,e){return t!=t?e==e:t!==e||t&&typeof t=="object"||typeof t=="function"}i(T,"safe_not_equal");function R(t){return Object.keys(t).length===0}i(R,"is_empty");var M=typeof window<"u"?window:typeof globalThis<"u"?globalThis:global,v=class t{static{i(this,"ResizeObserverSingleton")}constructor(e){this.options=e,this._listeners="WeakMap"in M?new WeakMap:void 0}observe(e,n){return this._listeners.set(e,n),this._getObserver().observe(e,this.options),()=>{this._listeners.delete(e),this._observer.unobserve(e)}}_getObserver(){var e;return(e=this._observer)!==null&&e!==void 0?e:this._observer=new ResizeObserver(n=>{var s;for(let r of n)t.entries.set(r.target,r),(s=this._listeners.get(r.target))===null||s===void 0||s(r)})}};v.entries="WeakMap"in M?new WeakMap:void 0;var k=[];function L(t){let e=[],n=[];k.forEach(s=>t.indexOf(s)===-1?e.push(s):n.push(s)),n.forEach(s=>s()),k=e}i(L,"flush_render_callbacks");var W=["allowfullscreen","allowpaymentrequest","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","hidden","inert","ismap","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected"],V=new Set([...W]);function q(t,e){let n=t.$$;n.fragment!==null&&(L(n.after_update),w(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}i(q,"destroy_component");var B;typeof HTMLElement=="function"&&(B=class extends HTMLElement{static{i(this,"SvelteElement")}constructor(){super(),this.attachShadow({mode:"open"})}connectedCallback(){let{on_mount:t}=this.$$;this.$$.on_disconnect=t.map(E).filter(b);for(let e in this.$$.slotted)this.appendChild(this.$$.slotted[e])}attributeChangedCallback(t,e,n){this[t]=n}disconnectedCallback(){w(this.$$.on_disconnect)}$destroy(){q(this,1),this.$destroy=h}$on(t,e){if(!b(e))return h;let n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{let s=n.indexOf(e);s!==-1&&n.splice(s,1)}}$set(t){this.$$set&&!R(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}});var _=[];function S(t,e=h){let n,s=new Set;function r(l){if(T(t,l)&&(t=l,n)){let f=!_.length;for(let a of s)a[1](),_.push(a,t);if(f){for(let a=0;a<_.length;a+=2)_[a][0](_[a+1]);_.length=0}}}i(r,"set");function c(l){r(l(t))}i(c,"update");function o(l,f=h){let a=[l,f];return s.add(a),s.size===1&&(n=e(r)||h),l(t),()=>{s.delete(a),s.size===0&&n&&(n(),n=null)}}return i(o,"subscribe"),{set:r,update:c,subscribe:o}}i(S,"writable");var z=Object.defineProperty,u=i((t,e)=>z(t,"name",{value:e,configurable:!0}),"t"),d=typeof navigator<"u",C=u((t,e,n=1)=>{let s=u(async(...c)=>e(...c),"f"),r=u(async function(c,...o){let l=await s(...o);c.call(c,l)},"drain");d?t.onmessage=c=>{let o=c.ports[0],l=o.postMessage.bind(o);o.onmessage=({data:f})=>{r(l,...f.data)}}:"on"in t&&t.on("message",u(i(function c(o){let l=o.port,f=l.postMessage.bind(l);l.onmessage=({data:a})=>{r(f,...a.data)},t.off("message",c)},"e"),"ref"))},"workerInit");var Q=(t=>(t[t.OK=200]="OK",t[t.ERROR=400]="ERROR",t[t.WAITING=300]="WAITING",t[t.TERMINATED=0]="TERMINATED",t))(Q||{}),O=class{static{i(this,"p")}constructor(t){this.concurrency=t}pendingTasks=new p;activeTasks=0;async runTask(t){this.activeTasks++;try{await t()}finally{this.activeTasks--,this.runNext()}}runNext(){if(this.activeTasks<this.concurrency&&this.pendingTasks.length>0){let t=this.pendingTasks.shift();this.runTask(t)}}async add(t){return new Promise((e,n)=>{let s=u(async()=>{try{let r=await t();e(r)}catch(r){n(r)}},"wrappedTask");this.pendingTasks.push(s),this.runNext()})}};u(O,"PromisePool");var p=class{static{i(this,"a")}head;tail;_length;constructor(){this.head=null,this.tail=null,this._length=0}get length(){return this._length}push(t){var e={value:t,prev:this.tail,next:null};this.head?(e.prev=this.tail,e.next=this.head,this.tail.next=e,this.head.prev=e,this.tail=e):(this.head=e,this.tail=e,e.next=e,e.prev=e),this._length++}unshift(t){var e={value:t,prev:null,next:this.head};this.head?(e.next=this.head,e.prev=this.tail,this.head.prev=e,this.tail.next=e,this.head=e):(this.head=e,this.tail=e,e.next=e,e.prev=e),this._length++}pop(){let t=this.tail;if(this.head)t===this.tail?(this.head=null,this.tail=null):(this.tail=this.tail.prev,this.tail.next=this.head,this.head.prev=this.tail);else return;return this._length--,t.value}shift(){let t=this.head;if(this.head)this.head===this.tail?(this.head=null,this.tail=null):(this.head=this.head.next,this.head.prev=this.tail,this.tail.next=this.head);else return;return this._length--,t.value}[Symbol.iterator](){let t=this.head;return{next:()=>{if(!t)return{done:!0,value:void 0};let e=t.value;return t=t.next,{done:!1,value:e}}}}};u(p,"Queue");var A=class extends Worker{static{i(this,"y")}constructor(t,e={}){super(t,e)}postMessage(t,e){super.postMessage(t,e)}addEventListener(t,e,n){n?.once?d?super.addEventListener(t,e,Object.assign({},n,{once:!1})):super.once(t,e):d?super.addEventListener(t,e,Object.assign({},n,{once:!1})):super.addEventListener(t,e)}removeEventListener(t,e,n){super.removeEventListener(t,e)}};u(A,"BrowserImpl");var H=A,G=d?globalThis.MessageChannel:MessageChannel,U='const{parentPort,workerData}=require("worker_threads"),func=($1),f=function(...e){return new Promise((r,j)=>{try{r(func.apply(func,e))}catch(e){j(e)}})};parentPort.on("message",e=>{const p=e.port;p.onmessage=async({data})=>{p.postMessage(await f(...data.data))}})',K="const H=async(...a)=>($1).apply(null, a),M=p=>({data})=>{ return H(...data.data).then(r=>p.postMessage(r))};onmessage=e=>{try{const p=e.ports[0];p.onmessage=M(p)}catch(e){postMessage({data:null,error:e,status:500})}}";function j(t){let e=t.toString();return d?K.replace("$1",e):U.replace("$1",e)}i(j,"w");u(j,"funcToString");function D(t,e){return new H(t,e)}i(D,"E");u(D,"createWorker");var at=u(()=>new Promise(t=>queueMicrotask(t)),"yieldMicrotask"),m={Inline:"inline",InlineBlob:"inline-blob",File:"file"},N=class{static{i(this,"T")}constructor(t,e){this.src=t,this.config=e}};u(N,"AbstractThread");var x=class extends N{static{i(this,"d")}constructor(t,e={once:!0,id:0,type:void 0,maxConcurrency:null}){switch(super(t,e),this.config=e,this.resolvers=new p,this.config.maxConcurrency=e.maxConcurrency===null?null:Math.max(1,this.config.maxConcurrency??1),typeof this.config.maxConcurrency=="number"&&(this.pool=new O(this.config.maxConcurrency)),typeof t){case"function":let r=j(t);d?(this.src=URL.createObjectURL(new Blob([r],{type:"text/javascript"})),this.type=m.InlineBlob):(this.src=r,this.type=m.Inline,this.options={eval:!0});break;case"string":this.src=t,this.type=m.File;break;case"object":this.src=t,this.type=m.File;default:throw new TypeError("Invalid source. Expected type 'function' or 'string', received "+typeof t)}this.config.type!==void 0&&(this.options.type=this.config.type);let{port1:n,port2:s}=new G;this.channel=s,this.channel.onmessage=this.onmessage,this.handle=D(this.src,this.options),this.handle.postMessage(d?void 0:{port:n},[n])}_activeCount=0;options={};get activeCount(){return this._activeCount}get id(){return this.config.id??0}get isBusy(){return this.maxConcurrency?this.activeCount>=this.maxConcurrency:!1}get maxConcurrency(){return this.config.maxConcurrency}onmessage=t=>{this.resolvers.shift().resolve(t.data),this.maxConcurrency&&this._activeCount--,this.config?.once&&this.terminate()};addTask=(...t)=>this.pool.add(()=>new Promise((e,n)=>{this.resolvers.push({resolve:e,reject:n}),this.channel.postMessage({data:t})}));send(...t){return this._activeCount++,this.addTask.call(this,...t)}onMessage(t){let e=u(n=>t(n.data),"handleMessage");return this.channel.addEventListener("message",e),()=>{this.channel.removeEventListener("message",e)}}async terminate(){return this.type==="inline-blob"&&URL.revokeObjectURL(this.src),this.handle.terminate(),this.channel.close(),0}};u(x,"ThreadImpl");var y=class extends x{static{i(this,"l")}constructor(t,e){super(t.toString(),e)}};u(y,"Thread");var g=class extends x{static{i(this,"c")}constructor(t,e){super(t,e)}};u(g,"InlineThread");var P=class{static{i(this,"v")}constructor(t,e,n=void 0){this.task=t,this.type=n,this.count=Math.max(e,1)}threads=[];count};u(P,"AbstractThreadPool");var $=class extends P{static{i(this,"h")}taskQueue;idleWorkerQueue;constructor(t){let{task:e,count:n,maxConcurrency:s=1,type:r}=t;super(e,n,r),this.count=Math.max(1,n),this.threads=new Array(n),this.taskQueue=new p,this.idleWorkerQueue=new p;let c=typeof e=="function"?g:y;for(let o=0;o<n;o++){let l=new c(e,{once:!1,id:o,maxConcurrency:s,type:r});this.threads[o]=l,this.idleWorkerQueue.push(l)}}exec(...t){let e=this.getWorker();return e?this.executeTask(e,...t):new Promise((n,s)=>{this.taskQueue.push({args:t,resolve:n,reject:s})})}getWorker(){let t=this.idleWorkerQueue.shift();return!t||t.isBusy?null:t}async executeTask(t,...e){let n=await t.send.call(t,...e);if(this.taskQueue.length>0){let s=this.taskQueue.shift();this.executeTask(t,...s.args).then(s.resolve).catch(s.reject)}else this.idleWorkerQueue.push(t);return n}async terminate(){await Promise.all(this.threads.map(t=>t.terminate()))}};u($,"ThreadPool");var X=Symbol("[[Setter]]"),Ft=i((t,e=1)=>{let n,s=typeof t=="function"?"inline":"module",r=s==="inline"?g:y,c=new r(t,{maxConcurrency:e,...s==="module"&&{type:"module"}});return{subscribe(o){let l=c.onMessage.bind(c)(f=>{n=f,o(n)});return o(n),()=>{l()}},set(){return(...o)=>this.send(...o)},[X]:o=>{n=o},send(...o){return c.send(o)}}},"channel"),F=class extends ${static{i(this,"ThreadPoolStore")}store=S({});#t=new Set([]);constructor(...e){super(...e);let n=i((s,r)=>this.store.update(c=>({...c,[s]:r})),"updater");for(let s of this.threads){let r=i(o=>n(s.id,o),"callback"),c=s.onMessage.bind(s)(r);this.#t.add(c)}}async terminate(){this.#t.forEach(e=>e()),this.#t.clear(),await super.terminate()}get subscribe(){return this.store.subscribe}},kt=i((t,{count:e=1,maxConcurrency:n=1})=>{let s=t,r=new F({task:s,count:e,maxConcurrency:n,type:"module"});return{send:r.exec.bind(r),subscribe:r.subscribe}},"pooled");export{Ft as channel,kt as pooled,C as workerInit};
